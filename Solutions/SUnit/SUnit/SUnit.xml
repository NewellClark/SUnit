<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SUnit</name>
    </assembly>
    <members>
        <member name="T:SUnit.Constraints.BinaryOperatorConstraint`1">
            <summary>
            A <see cref="T:SUnit.Constraints.IConstraint`1"/> that combines two <see cref="T:SUnit.Constraints.IConstraint`1"/>s using a binary operator.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SUnit.Constraints.BinaryOperatorConstraint`1.ApplyOperands(`0,SUnit.Constraints.IConstraint{`0},SUnit.Constraints.IConstraint{`0})">
            <summary>
            When overridden in a derived class, applies both operands to the specified value.
            </summary>
            <param name="value">The value to apply both operands to.</param>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns>The result of applying both operands to the value.</returns>
        </member>
        <member name="M:SUnit.Constraints.BinaryOperatorConstraint`1.Apply(`0)">
            <inheritdoc/>
        </member>
        <member name="P:SUnit.Constraints.BinaryOperatorConstraint`1.OperatorName">
            <summary>
            The name of the operator that is applied to the two sub-constraints.
            </summary>
        </member>
        <member name="M:SUnit.Constraints.BinaryOperatorConstraint`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:SUnit.Constraints.AndConstraint`1.ApplyOperands(`0,SUnit.Constraints.IConstraint{`0},SUnit.Constraints.IConstraint{`0})">
            <inheritdoc/>
        </member>
        <member name="P:SUnit.Constraints.AndConstraint`1.OperatorName">
            <inheritdoc/>
        </member>
        <member name="M:SUnit.Constraints.OrConstraint`1.ApplyOperands(`0,SUnit.Constraints.IConstraint{`0},SUnit.Constraints.IConstraint{`0})">
            <inheritdoc/>
        </member>
        <member name="P:SUnit.Constraints.OrConstraint`1.OperatorName">
            <inheritdoc/>
        </member>
        <member name="M:SUnit.Constraints.XorConstraint`1.ApplyOperands(`0,SUnit.Constraints.IConstraint{`0},SUnit.Constraints.IConstraint{`0})">
            <inheritdoc/>
        </member>
        <member name="P:SUnit.Constraints.XorConstraint`1.OperatorName">
            <inheritdoc/>
        </member>
        <member name="M:SUnit.Constraints.Constraint.FromPredicate``1(System.Predicate{``0})">
            <summary>
            Creates a new <see cref="T:SUnit.Constraints.IConstraint`1"/> from the specified <see cref="T:System.Predicate`1"/>.
            </summary>
            <typeparam name="T">The type of value that the constraint applies to.</typeparam>
            <param name="predicate">The predicate to apply to values that the constraint is applied to.</param>
            <returns>A new <see cref="T:SUnit.Constraints.IConstraint`1"/> that uses the specified <see cref="T:System.Predicate`1"/>.</returns>
        </member>
        <member name="M:SUnit.Constraints.Constraint.NullIsFalse``1(System.Predicate{``0})">
            <summary>
            Wraps a <see cref="T:System.Predicate`1"/> in another predicate so that it treats null values as false.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="predicate">The predicate to wrap.</param>
            <returns>A new predicate that calls the supplied predicate, but always returns false when given null values.</returns>
        </member>
        <member name="M:SUnit.Constraints.Constraint.NullFriendlyEquality``2(``0,``1,System.Func{``0,``1,System.Boolean})">
            <summary>
            Applies the specified equality function to the two operands ONLY if neither operand is null. If both operands are null,
            returns true. If one is null, returns false.
            </summary>
            <typeparam name="TLeft"></typeparam>
            <typeparam name="TRight"></typeparam>
            <param name="left"></param>
            <param name="right"></param>
            <param name="equalityFunction">The equality function to apply if neither operand is null.</param>
            <returns>If both operands are null, returns true. If exactly one is null, returns false. Otherwise,
            uses the supplied equality function.</returns>
        </member>
        <member name="M:SUnit.Constraints.Constraint.TryGetCount(System.Collections.IEnumerable)">
            <summary>
            Checks if an <see cref="T:System.Collections.IEnumerable"/> is actually a collection. If so, returns the count. Otherwise, 
            returns null.
            </summary>
            <param name="sequence"></param>
            <returns>The number of items in the collection if the sequence was actually a collection. Otherwise, null.</returns>
        </member>
        <member name="M:SUnit.Constraints.Constraint.TryGetCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks to see if the sequence is really a collection. If it is, returns the count. Otherwise, returns null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sequence"></param>
            <returns>The number of items in the sequence if it was actually a collection. Otherwise, null.</returns>
        </member>
        <member name="T:SUnit.Constraints.EqualToConstraint`1">
            <summary>
            Constraint that tests whether a value is equal to an expected value.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:SUnit.Constraints.FloatingPointEqualToConstraint.maxAllowedNormalizedError">
            <summary>
            The maximum allowed "normalized" error; in other words, the error divided by
            the largest argument.
            </summary>
        </member>
        <member name="T:SUnit.Constraints.IConstraint`1">
            <summary>
            A constraint that can be applied to value. 
            </summary>
            <typeparam name="T">The type of value the constraint can be applied to.</typeparam>
        </member>
        <member name="M:SUnit.Constraints.IConstraint`1.Apply(`0)">
            <summary>
            Applies the constraint to the specified value.
            </summary>
            <param name="value">The value to apply the constraint to.</param>
            <returns>Whether the value satisfies the constraint.</returns>
        </member>
        <member name="M:SUnit.Constraints.IConstraint`1.op_LogicalNot(SUnit.Constraints.IConstraint{`0})">
            <summary>
            Creates a new <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes if its operand fails.
            </summary>
            <param name="operand"></param>
            <returns>A <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes if the operand fails.</returns>
        </member>
        <member name="P:SUnit.Constraints.IConstraint`1.Inverted">
            <summary>
            Creates a new <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes when the current <see cref="T:SUnit.Constraints.IConstraint`1"/> fails.
            </summary>
        </member>
        <member name="M:SUnit.Constraints.IConstraint`1.op_BitwiseAnd(SUnit.Constraints.IConstraint{`0},SUnit.Constraints.IConstraint{`0})">
            <summary>
            Creates a <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes if both operands pass.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>A new <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes if both operands pass.</returns>
        </member>
        <member name="M:SUnit.Constraints.IConstraint`1.op_BitwiseOr(SUnit.Constraints.IConstraint{`0},SUnit.Constraints.IConstraint{`0})">
            <summary>
            Creates a <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes if either or both operands passes.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>A new <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes if either or both operands pass.</returns>
        </member>
        <member name="M:SUnit.Constraints.IConstraint`1.op_ExclusiveOr(SUnit.Constraints.IConstraint{`0},SUnit.Constraints.IConstraint{`0})">
            <summary>
            Creates a <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes if exactly one operand passes, but fails if both 
            operands pass or if both operands fail.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>A new <see cref="T:SUnit.Constraints.IConstraint`1"/> that passes if exactly one operand passes.</returns>
        </member>
        <member name="T:SUnit.Constraints.SetEqualityConstraint`1">
            <summary>
            A constraint that compares two sequences for set-equality. Order doesn't matter, and duplicates are ignored.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:SUnit.Test">
            <summary>
            The return type of all unit tests in <see cref="N:SUnit"/>.
            </summary>
        </member>
        <member name="P:SUnit.Test.Passed">
            <summary>
            Indicates whether the test passed.
            </summary>
        </member>
        <member name="M:SUnit.Test.ToString">
            <summary>
            Overridden to indicate test status.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SUnit.Test.op_True(SUnit.Test)">
            <summary>
            Indicates whether the <see cref="T:SUnit.Test"/> passed.
            </summary>
            <param name="operand"></param>
            <returns>True if the test passed.</returns>
        </member>
        <member name="M:SUnit.Test.op_False(SUnit.Test)">
            <summary>
            Indicates whether the <see cref="T:SUnit.Test"/> failed.
            </summary>
            <param name="operand"></param>
            <returns>True if the test failed.</returns>
        </member>
        <member name="M:SUnit.Test.op_LogicalNot(SUnit.Test)">
            <summary>
            Creates a new test by inverting the current test.
            </summary>
            <param name="operand">The test to invert.</param>
            <returns>A new test that passes when the current test fails.</returns>
        </member>
        <member name="T:SUnit.Test.BinaryOperatorTest">
            <summary>
            A <see cref="T:SUnit.Test"/> that applies a binary operator to two other <see cref="T:SUnit.Test"/>s. 
            </summary>
        </member>
        <member name="M:SUnit.Test.op_BitwiseAnd(SUnit.Test,SUnit.Test)">
            <summary>
            Creates a <see cref="T:SUnit.Test"/> that only passes if both operands pass.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>A <see cref="T:SUnit.Test"/> that only passes if both operands pass.</returns>
        </member>
        <member name="M:SUnit.Test.op_BitwiseOr(SUnit.Test,SUnit.Test)">
            <summary>
            Creates a <see cref="T:SUnit.Test"/> that passes if either or both operands pass.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>A <see cref="T:SUnit.Test"/> that passes if either operand, or both operands, passes.</returns>
        </member>
        <member name="M:SUnit.Test.op_ExclusiveOr(SUnit.Test,SUnit.Test)">
            <summary>
            Creates a <see cref="T:SUnit.Test"/> that passes if exactly one operand passes, but fails if neither operand
            passes or if both operands pass.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>A <see cref="T:SUnit.Test"/> that passes if exactly one operand passes.</returns>
        </member>
        <member name="P:SUnit.Test.Pass">
            <summary>
            Gets a test that always passes.
            </summary>
        </member>
        <member name="P:SUnit.Test.Fail">
            <summary>
            Gets a test that always fails.
            </summary>
        </member>
        <member name="M:SUnit.Test.LogicalNot(SUnit.Test)">
            <summary>
            Creates a new <see cref="T:SUnit.Test"/> that passes when the operand fails.
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:SUnit.Test.BitwiseAnd(SUnit.Test,SUnit.Test)">
            <summary>
            Named alias for operator AND.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SUnit.Test.BitwiseOr(SUnit.Test,SUnit.Test)">
            <summary>
            Named alias for operator |.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SUnit.Test.Xor(SUnit.Test,SUnit.Test)">
            <summary>
            Named alias for operator XOR.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:SUnit.Utilities">
            <summary>
            We need these methods, but we're not sure where they belong. 
            </summary>
        </member>
        <member name="M:SUnit.Utilities.DisplayValue(System.Object)">
            <summary>
            Displays an actual value that can be null.
            </summary>
            <param name="value">The value to display. Can be null.</param>
            <returns>The string representation for the value to display to the user.</returns>
        </member>
    </members>
</doc>
